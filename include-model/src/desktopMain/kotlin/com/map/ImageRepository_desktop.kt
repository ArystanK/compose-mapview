package com.map

import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import java.util.concurrent.ConcurrentHashMap

actual fun createDownloadImageRepository(): ImageRepository =
    if (USE_FAKE_REPOSITORY_ON_DEKSTOP) {
        createFakeRepository()
    } else {
        createRealRepository()
    }


private fun createRealRepository() = object : ImageRepository {
    val ktorClient: HttpClient = HttpClient(CIO)

    override suspend fun getImage(tile: Tile): Picture {
        val byteArray: ByteArray = with(tile) {
            ktorClient.get<ByteArray>("https://api.maptiler.com/maps/streets/$zoom/$x/$y.png?key=$SECRET_API_KEY")
        }
        return Picture(
            url = "autogenerated $tile",
            image = byteArray,
            width = TILE_SIZE,
            height = TILE_SIZE
        )
    }
}

private fun createFakeRepository() = object : ImageRepository {
    override suspend fun getImage(tile: Tile): Picture {
        val byteArray = mkBitmap(tile.zoom, tile.x, tile.y)
        return Picture(
            url = "autogenerated $tile",
            image = byteArray,
            width = TILE_SIZE,
            height = TILE_SIZE
        )
    }

}

actual fun decorateWithInMemoryCache(imageRepository: ImageRepository): ImageRepository = object : ImageRepository {

    val cache: MutableMap<Tile, Picture> =
        ConcurrentHashMap()//todo LRU cache как в докладе Тагира Валеева LinkedHashMap

    override suspend fun getImage(tile: Tile): Picture {
        //todo вставать в блокировку по ключу или вешать обработчики на ожидание по ключу
        val fromCache = cache[tile]
        if (fromCache != null) {
            return fromCache
        }
        val result = imageRepository.getImage(tile)
        cache[tile] = result
        return result
    }
}

actual fun decorateWithDiskCache(imageRepository: ImageRepository): ImageRepository = TODO()
