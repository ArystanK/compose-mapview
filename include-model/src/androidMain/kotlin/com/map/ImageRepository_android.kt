package com.map

import android.content.Context
import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.util.concurrent.ConcurrentHashMap

actual fun createDownloadImageRepository(): ImageRepository = createRealRepository()

private fun createRealRepository() = object : ImageRepository {
    val ktorClient: HttpClient = HttpClient(CIO)

    override suspend fun getImage(tile: Tile): Picture {
        val byteArray = ktorClient.get<ByteArray>(tile.tileUrl)
        return Picture(
            url = "autogenerated $tile",
            image = byteArray,
            width = TILE_SIZE,
            height = TILE_SIZE
        )
    }
}

actual fun decorateWithInMemoryCache(imageRepository: ImageRepository): ImageRepository = object : ImageRepository {
    val cache: MutableMap<Tile, Picture> = ConcurrentHashMap()//todo LRU cache как в video Тагира Валеева LinkedHashMap
    override suspend fun getImage(tile: Tile): Picture {
        //todo вставать в блокировку по ключу или вешать обработчики на ожидание по ключу как в видео Романа Елизарова, actor
        val fromCache = cache[tile]
        if (fromCache != null) {
            return fromCache
        }
        val result = imageRepository.getImage(tile)
        cache[tile] = result
        return result
    }
}

actual fun decorateWithDiskCache(imageRepository: ImageRepository): ImageRepository = object : ImageRepository {
    override suspend fun getImage(tile: Tile): Picture { TODO() }

    fun isFileExists(path:String):Boolean = File(path).exists()
    fun getFileSeparator():String= File.separator
    fun cacheImage(path: String, picture: Picture) {
        try {
            FileOutputStream(path).write(picture.image)
//        FileOutputStream(path).use { out ->
//            picture.image.compress(Bitmap.CompressFormat.PNG, 100, out)
//        }
//
//        val bw =
//            BufferedWriter(
//                OutputStreamWriter(
//                    FileOutputStream(path + cacheImagePostfix), StandardCharsets.UTF_8
//                )
//            )
//
//        bw.write(picture.url)
//        bw.write("\r\n${picture.width}")
//        bw.write("\r\n${picture.height}")
//        bw.close()

        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    fun clearCache(context: Context) {

        val directory = File(context.cacheDir.absolutePath)

        val files: Array<File>? = directory.listFiles()

        if (files != null) {
            for (file in files) {
                if (file.isDirectory)
                    continue

                file.delete()
            }
        }
    }
}

private fun loadFullImageBlocking(url: String): Picture {
//    try {
//        val connection: HttpURLConnection = URL(url).openConnection() as HttpURLConnection
//        connection.connectTimeout = 5000
//        connection.connect()
//
//        val input: InputStream = connection.inputStream
//        val bitmap: Bitmap? = BitmapFactory.decodeStream(input)
//        if (bitmap != null) {
//            return Picture(
//                url = url,
//                image = bitmap,
//                width = bitmap.width,
//                height = bitmap.height
//            )
//        }
//    } catch (e: Exception) {
//        e.printStackTrace()
//    }

    TODO()
//    return Picture(url = url, image = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888))
}

