package com.map

import io.ktor.client.*
import io.ktor.client.request.*
import kotlinx.coroutines.await
import kotlinx.coroutines.launch
import org.w3c.dom.Image
import org.w3c.dom.ImageBitmap
import org.w3c.files.Blob
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine
import kotlin.js.Promise

actual fun createDownloadImageRepository(): ImageRepository = createRealRepository()

private fun createRealRepository() = object : ImageRepository {
    val ktorClient: HttpClient = HttpClient()

    override suspend fun getImage(tile: Tile): Picture {
        val promise: Promise<ImageBitmap> = suspendCoroutine { continuation ->
            val img = Image() // Create new img element
            img.onload = {
                continuation.resume(
                    createImageBitmap(img)
                )
            }
            img.src = tile.tileUrl
        }
        return Picture(
            url = "autogenerated $tile",
            image = ImageBitmapContainer(promise.await()),
            width = TILE_SIZE,
            height = TILE_SIZE
        )
    }
}

actual fun decorateWithInMemoryCache(imageRepository: ImageRepository): ImageRepository = object : ImageRepository {
    val cache: MutableMap<Tile, Picture> = HashMap()
    override suspend fun getImage(tile: Tile): Picture {
        val fromCache = cache[tile]
        if (fromCache != null) {
            return fromCache
        }
        val result = imageRepository.getImage(tile)
        cache[tile] = result
        return result
    }
}

actual fun decorateWithDiskCache(imageRepository: ImageRepository): ImageRepository = object : ImageRepository {
    // Для js пока не сделал дисковое хранилище
    override suspend fun getImage(tile: Tile): Picture = imageRepository.getImage(tile)
}

external fun createImageBitmap(data: Blob):Promise<ImageBitmap>
external fun createImageBitmap(data: Image):Promise<ImageBitmap>
